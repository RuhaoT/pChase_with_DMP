# Experiment: JIT function performance

## Abstract
本实验意在使用Linux perf指令研究pChase中不同JIT函数的性能，特别是预取性能。

## 第一次实验
第一次实验结果、具体参数请见对应文件夹。

要点：
- 第一次实验loop_size恒置为0，也就是没有给软件预取机制任何预取时间
- 没有对硬件预取机制进行任何操作（关闭或设置）

实验结果：
1. 根据数据分析表明，所有的Cache访存均未命中。同时观测到了一些不可信的异常数据，推测是由perf样本过少导致的（这些数据均发生在样本很少的地方）。
2. 控制变量到仅预取方式不同时，不同次实验的运行时间基本一致，但使用prefetchNTA选项是个例外。
3. 控制变量到仅访存顺序不同时，不同次实验的运行时间具有显著差别。

分析：
- prefetchNTA选项与其余选项不同，除了改变预取方式外，prefetchNTA还指定预取数据在缓存中存放的位值来防止缓存污染，推测prefetchNTA的执行时间更长。同时不认为是由于缓存命中率降低引起的（尽管理论上更合理），因为数据不支持这个结论。
- 不同访存顺序的运行时间差异可能是由硬件预取器造成的，random访问顺序耗时更长也支持这个结论。但是这个猜想有个明显的问题，那就是缓存命中率自始至终都没有明显差别。
- 实验中也忽视了一个因素：实验只控制了不同变量下的链表*代表的存储空间大小*相同，但是没有控制链表内的*指针跳数*相同。这个因素可能导致了不同访存顺序的运行时间差异。但是这个猜想也有不合理之处，即跳数最大（stride取最小为1）的链表运行时间也远远低于采用random访存顺序的小跳数链表。
- 不同访存顺序的运行时间差异也可能是由以上因素共同决定的。同时我质疑perf提供的Cache-miss事件选项，这个事件选项是否包含了所有的Cache结构？是否统计了所有的Cache-miss？

下一步：
- 首先需要验证random访存顺序的跳数是否能在同变量下保持一致，我对相关代码理解的不是很透彻。
- 由于硬件预取器无法关闭（或无法在软件预取器打开时关闭？），无法很好的排除硬件预取器的干扰，因此需要明确硬件预取器对缓存命中率和运行时常到底产生了多大的影响。Perf提供了更精细化的缓存事件选项，可以使用这些选项来验证硬件预取器的影响。

## 第二次实验
完整结果请见对应表格。

要点：
- 对代表不同存储空间的链表，其他变量相同的情况下反复生成了多次，意在观察不同链表的跳数是否有显著差异。

实验结果：
- 没有。可以排除random对实验带来的不确定性。

## 第三次实验
完整结果请见相关表格。

要点：
- 没有使用任何prefetch选项，目的是观察硬件预取器。
- 没有使用更宏观的Cache-miss事件，而是对不同级的缓存添加事件，详细观察。
- 由于perf每次能记录等事件数目有限制，因此对不同的事件分批次做了两次实验。

实验结果：
- L1-dcache-load-misses事件的数量与L1-dcache-loads事件的数量相同，说明L1缓存没有命中。
- LLC-load-misses事件的数量与LLC-loads事件的数量相同，说明LLC缓存没有命中。
- 证实了Cache-miss事件选项结果正确可用。
- 无论使用何种访存顺序，访问链表的总操作数在其他变量相同时保持一致。
- 没有观察到缺页错误。
- 执行时间仍然存在巨大差异。

猜想：
- 根据L1缓存和LLC缓存的表现，基本排除了硬件预取器起作用的可能性。

## 第四次实验
完整结果请见相关表格。

要点：
- 执行时间的巨大差异目前仍然无法解释，但暂时不影响后续实验。
- 本次实验主要观察Loop size大小即不同预取方式对缓存命中率的影响。观察预取方式从根本上是否生效。
- loop size选择了与pChase测试脚本相同的参数。

实验结果：
- 无论何种情况，缓存命中率均不超过5%。
- 不同变量下的缓存命中率没有显著差异。
- **证明了SSE指令集在本设备上无法为pChase提供有效预取，但是这个结论与pChase中设置预取指令的初衷相冲突。**